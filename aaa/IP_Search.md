最近同事说有个需求，QPS会很高，看有没有什么好的算法一起讨论下。由于太久没有正经写java了，就动手了一个例子(实在是最近主要写python、scala和shell了，连调试C++代码都比java多，虽然我不会)。由于主要工作还是大数据相关，就手动执行一些spark之类的job等结果的间隙写点，所以还是写了很长时间，虽然代码没几行。   
主要需求是，根据ip查找其所在的网段（已有ip网段+子网掩码+相关信息）获得相关信息。功能很简单，主要就是如何使用尽量少的资源，性能尽可能高。最开始考虑过B树，考虑过用图的邻接矩阵，然后在打算用邻接矩阵的时候发现其实用不了那么复杂，二叉树足以。   
接下来说以下我的想法和实现，大家如果由好的想法希望能与我讨论。   
代码在：https://github.com/saaavsaaa/tools   
测试：https://github.com/saaavsaaa/tools/blob/master/src/test/java/date/iterator/tools/ip/IPTreeTest.java   
已经发到中央仓库了：https://mvnrepository.com/artifact/date.iterator.tools/tools   
首先，如果不想枚举IP，想通过IP段和掩码确定一个IP是否在其间，我能想到的办法就是对比二进制，如果指定掩码长度的IP段的二进制串是待查找IP的二进制串的前缀，那么这个IP就数据这个网段，例如：  
```
211.139.193.0/24 的前24 位：1101 0011 1000 1011 1100 0001 // 00000000
211.139.193.20:            1101 0011 1000 1011 1100 0001 00010100
```
只要进行匹配就好了，当然不能拿IP去和已有的每一个网段匹配，那最坏情况就是由网段数量及对应掩码决定了，这个复杂度是不能接受的，而且为了在内存中查找，所有网段都放在内存里也是不小的消耗。
于是我想，二进制的第一位只有0和1两种情况，前两位只有两个0和1的组合2²种情况，而其实不需要表示出00、01、10、11，只要用树的形式：
|  |  |  | root(null) |  |  |  |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| | |↙| |↘| | |  
| |0| | | |1| |
|↙| |↘| |↙| |↘| 
|0| |1| |0| |1|

就可以节省2个，这样到32位就节省非常多了，虽然我们只有4W多个网段。这种方式即使保存所有IP，也就是与第32位2³²=4294967296个同数量级，因为几何级数全集与末项同阶。当然，这也是个不小的数字，但是都是0和1完全可以用一个bit去存，那全部IP就需要512M，换成只存网段就小多了，我加载了3W多个网段、对应网段的IP地址如“211.139.193.0”和所属地如“北京”，总共只用了0.7M内存，看上去全部加上也不用1M。
同时，检索也不用匹配所有的网段，只要顺着树一个节点一个节点往下找就好了。   
节点定义：
```
public class BitNode {
    private boolean value; // 1 bit保存0 或 1，其实都没必要保存，因为用了二维数组，规定了左0右1，查的时候按方向查就好，这个属性就显得多余了，事实上没用上
    private String key; // 我原意是打算保存个redis的key在内存里，检索之后拿key去查相关信息，不过现在看来似乎都放内存也可以
    private String ip;
    private final BitNode[] children = new BitNode[2]; //由于值就是0或1，干脆直接二维数组算了，代码写起来简单，不用左右子节点的写法了
    
    public String searchInChildren(int[] ipBits) //由于不想用递归实现，所以节点中只有个查找方法，具体代码去github看吧，没几行，又少又简单，实在没什么好介绍的。
```
树中其实只有appendIP一个方法有用，树高之类的属性只是暂时放着，万一那天想做个视图之类的时候可能会用上，代码就去github看吧，同上没有什么可特别介绍的。   
这样每个IP检索最多只需要查找32次，current.getChildren()[bits[i]]，就是最坏情况，其实这种最坏并没那么坏，因为没有31位都匹配到了，但是不存在对应网段的时候，应该说就没有31位的掩码。不过即使是32，它也是个常数，我感觉应该足够用了。   

-----
微信公众号：

![Image](/ppp/0.png)


### 串
#### ADT (Abstract Data Type)抽象数据类型
字符串结构简单，主要讲它相关的算法，串匹配，查找，重点 indexof   
字符串定义：由来自某个字母表 ∑ 的字符所组成的有限序列：S = a₀ a₁ a₂ ... a<sub>n-1</sub> ∈  ∑*    
线性序列，不要求字符互异，每一元素是一个字符，可用Vector或List实现   
特征鲜明，通常，字符的种类不多，而串长 = n >> |∑|   
比如：
| 视作字符串 | : | 字符组成只有 |
|:-:|:-:|:--|
| 英文文章| |['A' - 'z'] ∪['a' - 'z'] ∪ { ' ', '.'，',' ，... } |
|C++程序| : |{ 95个可打印字符 } ∪ { LF，CR }* |
|天然蛋白质| : |{ 21种氨基酸 }* |
|DNA| : |{A, C, G, T}* |
|RNA| : |{A, C, G, U}* |
|二进制| : |{0,1}* |

相等: S\[0，n) = \[0，m) 长度相等 (n = m)，且对应的字符均相同( S[i] = T[i] )   
子串: substr(i，k) = s\[i，i + k)， 0 ≤ i < n, 0 ≤ k 亦即，从S[i]起的连续 k 个字符   
前缀: S.prefix(k) = S.substr(0，k) = s\[0，k)，0 ≤ k ≤ n 亦即，S中最靠前的 k 个字符
后缀: S.suffix(k) = S.substr(n - k, k) = s\[n - k, n)，0 ≤ k ≤ n 亦即，S中最靠后的 k 个字符   
( 联系: S.substr(i， k) = S.prefix(i + k).suffix(k) )   
空串: S[0, n-0 ] 也是任何串的子串、前缀、后缀   
任何串都是自身的子串、前缀、后缀   
长度严格小于原串的子串、前缀与后缀也称作真子串、真前缀与真后缀   
```
i k ：秩，T P ：其他串
length()
charAt(i)  
substr(i，k)
prefix(k)
suffix(k)
concat(T)   拼接字符串
equal(T)
indexOf(P)  索引接口，之后大量讨论它的高效实现
```
#### 串匹配
记 n = |T| (全部文本的长度) 和 m = |P| (待从全部文本中找出的目标长度，不可视为常数)，通常有 n >> m >> 2(常数)   //比如，100,000 >> 100 >> 2   
Pattern matching 的几个层次：   
detection : P是否出现?
location : 首次在哪里出现?    //本章主要讨论的问题   
counting : 共有几次出现?      // find /c "2013" students.txt   
enumeration : 各出现在哪里?   //find "2013" students.txt   
匹配的评估方法和策略：    
不适用：采用随机文本 T 和串 P，随机采样，然后通过数学上的概率分析或实际测量的统计。因为T和P不相等，T中部分字符和P的字符需要一一对应，所以匹配成功概率远低于失败概率   
以 ∑ = {0 , 1}* 为例    | { 长度为 m 的P }| = 2ᵐ   
            | { 长度为 m 且在 T 中出现的 P } | = n - m + 1 < n   
匹配成功的概率 = n/2ᵐ << 100,000/2¹⁰⁰ (例如：n大致取10⁵,m取10²，2¹⁰⁰封底估算约10³⁰) < 10⁻²⁵   （如此之低的概率完全有可能会被任何一种微小的波动所掩盖）   
如此，将无法对算法做充分测试   

合适的策略，随机T，对成功、失败的匹配分别测试:   
  成功:在T中，随机取出长度为m的子串作为P;分析平均复杂度   
  失败:采用随机的P;统计平均复杂度。针对失败的情况可以继续沿用以前完全随机的方法   

#### 蛮力匹配
效率很差，但是可以从它为起点开始优化，自左向右以字符为单位，依次移动模式串直到在某个位置，发现匹配。依次用T的每一个字符为匹配的起点，与完整的P匹配，最差情况是n个字符，匹配 n-m 次完全匹配（因为最后已经不足P的长度了，一定不匹配），T中从每一个开始匹配m次，知道最后一个位置才发现不成功，例如：从000000000000000000000000000000000000000000000中匹配00001，前面所有的匹配都是到第5次比较才发现不匹配。最差复杂度为O(mn)。   
首次在哪里出现，两种蛮力匹配实现方法：
```
版本一：
在 T[i - j , i - j + m ) 中匹配 P[0 , m)，每次从 i-j 位置开始匹配，j 是滑动指针，每匹配一次 i 自增1。
int match( char * P, char * T ) {
  size_t n = strlen(T), i = 0;
  size_t m = strlen(P), j = 0;
  while ( j < m && i <n )   //自左向右逐个比对字符
    if （ T[i] == P[j] ){ i ++; j ++;}   //若匹配，则转到下一对字符
    else { i -= j - 1; j = 0; }   //否则，T回退、P复位。i在一轮匹配后需要退到这一轮开始处的下一个位置
  return i - j;
} // 当 j 不小于 m，则匹配成功跳出循环。i 不小于 n 时，匹配失败循环借宿。i 的最大值是 n - 1，j 的最大值是 m - 1。i、j 都止步于 n - 1 时在结尾匹配成功，此时 i - j = n - m；任意匹配成功的情况 j 都等于 m - 1，而 i 都小于等于 n - 1，所以 i - j ≤ n - m 是匹配成功，i - j ＞ n - m 时匹配失败。

版本二：
在 T[i , i + m) 中查找 P[0, m)，T 的起始索引 i，每次匹配 T 的第 i + j 位置的元素
int match( char * P,char * T ){
  size_t n = strlen(T), i = 0;    //T[i]与P[0]对齐
  size_t m = strlen(P), j;        //T[i + j]与P[j]对齐
  for ( i = 0; i < n - m + 1; i ++) {     //T从第i个字符起，与
    for ( j = 0; j < m; j++)              //P中对应的字符逐个比对
      if ( T[i + j] != p[j] ) break;      //若失配，P整体右移一个字符，重新比对
    if ( m <= j ) break;      //找到匹配子串
  }
  return i;
} // i ≤ n - m 成功；i > n - m 则失败。
```
蛮力匹配并不是一无是处。习题解析中有证明：随着字母表规模的扩大，最坏情况出现的概率将急剧下降，以致平均而言可达常数次，意味着就期望的意义而言可达线性次 O(n)。可以找到算法在不需要这个前提的情况下达到线性。


-----
[edit](https://github.com/saaavsaaa/saaavsaaa.github.io/edit/master/aaa/Structure_Abstract3.md)

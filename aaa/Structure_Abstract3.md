### 串
#### ADT (Abstract Data Type)抽象数据类型
字符串结构简单，主要讲它相关的算法，串匹配，查找，重点 indexof   
字符串定义：由来自某个字母表 ∑ 的字符所组成的有限序列：S = a₀ a₁ a₂ ... a<sub>n-1</sub> ∈  ∑*    
线性序列，不要求字符互异，每一元素是一个字符，可用Vector或List实现   
特征鲜明，通常，字符的种类不多，而串长 = n >> |∑|   
比如：
| 视作字符串 | : | 字符组成只有 |
|:-:|:-:|:--|
| 英文文章| |['A' - 'z'] ∪['a' - 'z'] ∪ { ' ', '.'，',' ，... } |
|C++程序| : |{ 95个可打印字符 } ∪ { LF，CR }* |
|天然蛋白质| : |{ 21种氨基酸 }* |
|DNA| : |{A, C, G, T}* |
|RNA| : |{A, C, G, U}* |
|二进制| : |{0,1}* |

相等: S\[0，n) = \[0，m) 长度相等 (n = m)，且对应的字符均相同( S[i] = T[i] )   
子串: substr(i，k) = s\[i，i + k)， 0 ≤ i < n, 0 ≤ k 亦即，从S[i]起的连续 k 个字符   
前缀: S.prefix(k) = S.substr(0，k) = s\[0，k)，0 ≤ k ≤ n 亦即，S中最靠前的 k 个字符
后缀: S.suffix(k) = S.substr(n - k, k) = s\[n - k, n)，0 ≤ k ≤ n 亦即，S中最靠后的 k 个字符   
( 联系: S.substr(i， k) = S.prefix(i + k).suffix(k) )   
空串: S[0, n-0 ] 也是任何串的子串、前缀、后缀   
任何串都是自身的子串、前缀、后缀   
长度严格小于原串的子串、前缀与后缀也称作真子串、真前缀与真后缀   
```
i k ：秩，T P ：其他串
length()
charAt(i)  
substr(i，k)
prefix(k)
suffix(k)
concat(T)   拼接字符串
equal(T)
indexOf(P)  索引接口，之后大量讨论它的高效实现
```
#### 串匹配
记 n = |T| (全部文本的长度) 和 m = |P| (待从全部文本中找出的目标长度，不可视为常数)，通常有 n >> m >> 2(常数)   //比如，100,000 >> 100 >> 2   
Pattern matching 的几个层次：   
detection : P是否出现?
location : 首次在哪里出现?    //本章主要讨论的问题   
counting : 共有几次出现?      // find /c "2013" students.txt   
enumeration : 各出现在哪里?   //find "2013" students.txt   
匹配的评估方法和策略：    
不适用：采用随机文本 T 和串 P，随机采样，然后通过数学上的概率分析或实际测量的统计。因为T和P不相等，T中部分字符和P的字符需要一一对应，所以匹配成功概率远低于失败概率   
以 ∑ = {0 , 1}* 为例    | { 长度为 m 的P }| = 2ᵐ   
            | { 长度为 m 且在 T 中出现的 P } | = n - m + 1 < n   
匹配成功的概率 = n/2ᵐ << 100,000/2¹⁰⁰ (例如：n大致取10⁵,m取10²，2¹⁰⁰封底估算约10³⁰) < 10⁻²⁵   （如此之低的概率完全有可能会被任何一种微小的波动所掩盖）   
如此，将无法对算法做充分测试   

合适的策略，随机T，对成功、失败的匹配分别测试:   
  成功:在T中，随机取出长度为m的子串作为P;分析平均复杂度   
  失败:采用随机的P;统计平均复杂度。针对失败的情况可以继续沿用以前完全随机的方法   

#### 蛮力匹配
效率很差，但是可以从它为起点开始优化，自左向右以字符为单位，依次移动模式串直到在某个位置，发现匹配。依次用T的每一个字符为匹配的起点，与完整的P匹配，最差情况是n个字符，匹配 n-m 次完全匹配（因为最后已经不足P的长度了，一定不匹配），T中从每一个开始匹配m次，知道最后一个位置才发现不成功，例如：从000000000000000000000000000000000000000000000中匹配00001，前面所有的匹配都是到第5次比较才发现不匹配。最差复杂度为O(mn)。   
首次在哪里出现，两种蛮力匹配实现方法：
```
版本一：
在 T[i - j , i - j + m ) 中匹配 P[0 , m)，每次从 i-j 位置开始匹配，j 是滑动指针，每匹配一次 i 自增1。
int match( char * P, char * T ) {
  size_t n = strlen(T), i = 0;
  size_t m = strlen(P), j = 0;
  while ( j < m && i <n )   //自左向右逐个比对字符
    if （ T[i] == P[j] ){ i ++; j ++;}   //若匹配，则转到下一对字符
    else { i -= j - 1; j = 0; }   //否则，T回退、P复位。i在一轮匹配后需要退到这一轮开始处的下一个位置
  return i - j;
} // 当 j 不小于 m，则匹配成功跳出循环。i 不小于 n 时，匹配失败循环借宿。i 的最大值是 n - 1，j 的最大值是 m - 1。i、j 都止步于 n - 1 时在结尾匹配成功，此时 i - j = n - m；任意匹配成功的情况 j 都等于 m - 1，而 i 都小于等于 n - 1，所以 i - j ≤ n - m 是匹配成功，i - j ＞ n - m 时匹配失败。

版本二：
在 T[i , i + m) 中查找 P[0, m)，T 的起始索引 i，每次匹配 T 的第 i + j 位置的元素
int match( char * P,char * T ){
  size_t n = strlen(T), i = 0;    //T[i]与P[0]对齐
  size_t m = strlen(P), j;        //T[i + j]与P[j]对齐
  for ( i = 0; i < n - m + 1; i ++) {     //T从第i个字符起，与
    for ( j = 0; j < m; j++)              //P中对应的字符逐个比对
      if ( T[i + j] != p[j] ) break;      //若失配，P整体右移一个字符，重新比对
    if ( m <= j ) break;      //找到匹配子串
  }
  return i;
} // i ≤ n - m 成功；i > n - m 则失败。
```
蛮力匹配并不是一无是处。习题解析中有证明：随着字母表规模的扩大，最坏情况出现的概率将急剧下降，以致平均而言可达常数次，意味着就期望的意义而言可达线性次 O(n)。可以找到算法在不需要这个前提的情况下达到线性。

#### KMP算法:
最差线性   
蛮力之所以慢是因为当一次匹配失败与某个位置时，事实上从开始匹配的位置到该位置的（也就是已经进行过比较的）字符，事实上已经知道了，这一部分字符没有必要再次进行比较了   
如果记忆力足够好，前一部分完全可以不用再比较了，而从相同的前缀开始比较，避免回溯   
KMP算法构造了一张查询表，当发生失配时，比较的下一个位置只与模式串有关，而与主串无关。因为事实上在这样的—个时刻主串无非4个部分，当前匹配部分之外，已匹配的部分（前缀），未匹配部分（后缀），再加上在当前这一轮已经匹配的这个子串以及失配的这个字符。前缀和后缀对匹配的这个字符没有影响，而当前已匹配的子串（这一轮匹配中已匹配上的部分）和模式串的已匹配部分是一样的，所以接替当前失配字符而进行下一轮匹配的字符完全可以由模式串确定，那总共只有m种可能。KMP算法将所有这m种情况事先处理并且归纳整理为一张查询表（构造查询表next[0, m]:在任一位置P[j]处失败之后，将j替换为next[j]），与其说是借助强大的记忆，不如说是做好充分的预案。这一部分就是说，当发生失配时，这一轮已经匹配的部分中（因为匹配过，所以知道失配位置前面部分都有什么），如果失配位置之前的部分有一小部分刚好可以和模式串的头部一小部分一样，那下一轮匹配中，这一小部分就不用比较了，直接中这一小部分的下一个位置字符与当前失配位置的字符比较就可以了。例如从 0001 中查找 001，当匹配到第3位时，主串是 0，而模式串是 1，但是已知主串中前面都是 0，而主串的这部分与模式串相同，也就可以认为只和模式串有关。这时，第二位的 0 就不用比较了，而模式串中接替当前适配的 1 的是它第二位的0。所要构造的这个接替位置的表也就是要查询出这个接替位置的表。
|||||||||||||
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|0|0|0|1...|||...0|0|0|1...|||
|0|0|1(失配)|||||...0(因为第二个0接替了1，所以第一个0自然被带过来了，不用管它了)|0(接替1)|...|||
```
int match( char * P, char * T) {
  int * next = buildNext(P); //构造next表
  int n = (int) strlen(T)， i = 0; //文本串指针
  int m = (int) strlen(P), j = 0; //模式串指针
  while( j < m && i < n)   //自左向右，逐个比对字符
    if (0 > j || T[i] == P[j] ) { //若匹配
      i ++; j ++; //则携手共进
    } else //否则, P右移，T不回退
      j = next[j];
  delete [] next; //释放next表
  return i - j;
}
KMP 就是在此前蛮力算法的版本一的基础上改进得到的
```
KMP 通过排除掉很多不必要的对齐位置而快速右移，排除借助了的必要条件（某种模式串自身匹配性），KMP 在第 j 位失配，如果是用 t **取代** j，那么新的前缀 P\[0,t) 必须是原来的 P\[0,j) 的前缀，而原前缀中的 P\[j-t,j)  部分必须也是 P\[0,t) 的前缀（因为原前缀右移了 t 得到的P\[0,t)，说明 j-t 与 0 对齐了，它们相等）,这说明模式串必须有一个长度为 t 的前缀与长度为 t 的后缀彼此相等 P\[0,t) == P\[j-t,j) (长度都是t)亦即，在P[j]的前缀P\[0, j)中，所有匹配真前缀和真后缀的长度，子串首尾必须有一定的相似性。因此，一旦 T[i]≠P[j],可从 N(P，j) 中取某个 t ,令 P[t] 对准 T[i],并继续比对。模式串某部分真前缀和真后缀的相似性构成了 next 表   
KMP 不会尝试所有的 t，next 中对于每一个 j 只会给出一个特定的 t，t 越小移动的越快（j-t），next 会选择其中最大的 t，保证安全，保证 j-t 一定是不需要匹配的部分   


-----
[edit](https://github.com/saaavsaaa/saaavsaaa.github.io/edit/master/aaa/Structure_Abstract3.md)

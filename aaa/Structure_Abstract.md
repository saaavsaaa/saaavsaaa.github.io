## 绪论（上）

计算模型=计算机=信息处理工具    
所谓算法,即特定计算模型下,旨在解决特定问题的指令序列:   
输入 待处理的信息(问题)   
输出 经处理的信息(答案)   
正确性 的确可以解决指定的问题   
确定性 任一算法都可以描述为一个由基本操作组成的序列   
可行性 每一基本操作都可实现,且在常数时间内完成   
有穷性 对于任何输入，经有穷次基本操作,都可以得到输出   

有穷性的反例算法:Hailstore,≤ 1结束，> 1 偶数时 ÷ 奇数时 ×3+1。这个逻辑的程序暂时还没有办法证明是否所有输入都有穷，虽然还没有反例 42、7、27。     

好算法：正确、效率、健壮、可读   

数据结构和算法(DSA)想要优化，首先需要测量     
算法分析两个方面：     
正确性：算法功能与需求是否一致，可能需要借助数学工具进行证明     
成本：运行时间和所需的存储空间     
这里更多关注时间成本     
如何度量？如何比较？
求解问题实例意义不大，因为可能的实例太多，如何归纳？
计算成本 **一般情况下** 和问题规模相关，一般是正相关

必实验统计是最直接的方法,但不足以准确反映算法的真正效率。
不同的算法,可能更适应于不同规模的输入。
不同的算法，可能更适应于不同类型的输入。
同一算法，可能由不同程序员、用不同程序语言、经不同编译器实现。
同一算法,可能实现并运行于不同的体系结构、操作系统...

需要抽象出一种理想的平台或模型:例如图灵机模型
Tape 依次均匀地划分为单元格各注有某一字符，默认可以为'#'   
Alphabet字符的种类有限   
Head 总是对准某一单元格，并可读取和改写其中的字符，每经过一个节拍，可转向左侧或右侧的邻格   
Transition Function: (q, C; d, L/R, p)若当前状态为q且当前字符为c，则将当前字符改写为d ;转向左侧/右侧的邻格;转入p状态；一旦转入特定的状态'h'则停机   
图灵机实例：将二进制非负整数加一：全'1'的后缀翻转为全'0'，原最低位的'0'或'#'翻转为'1'：     
(<，1, 0, L, <) //左行，1->0，可能多次使用    
(<, 0, 1, R, >) //掉头，0->1     
(<，#，1,R,>)  // 或者遇到# 翻转为1 
(>, 0, 0, R, >) //右行   
(>, #，#，L, h) //复位   
复位是因为这一段有可能是一个算法的一部分，需要反复使用，这是一种规范，多通过接口形式规定     

RAM(Random Access Machine)模型：做加法时，需要先将常数放进寄存器，再对寄存器进行相加     
与图灵机相同：寄存器顺序编号，总数没有限制；基本操作仅需常数时间；     
与TM模型一样，RAM模型也是一般计算工具的简化与抽象，使我们可以独立于具体的平台,对算法的效率做出可信的比较与评判，算法效率不取决于CPU的主频，而取决与CPU的计算次数     
在这些模型中，算法的运行时间可转化为算法需要执行的基本操作次数，衡量算法效率的函数T(n) = 算法为求解规模为n的问题,所需执行的基本操作次数。   

大 O 记号(big-o notation)，更关心足够大的问题，注重考察成本的增长趋势而不是某个运算过程的局部细节   
渐进分析：当问题规模足够大后，计算成本如何增长   
当 n 足够大，对与输入规模为n的算法：   
需执行的基本操作次数   
需占用的存储单元数（通常可不考虑）   
多项式复杂度，舍掉低阶项

T(n)=0(f(n)) iff 彐 c > 0，当n>>2后,有T(n) < c.f(n)      
反映T(n)的增长趋势，T(n)时间复杂度常系数意义上的的上界(经过常系数放大能构成上界)，局部值不一定小于T(n)     
常数项可以忽略，低次项可以忽略 O(sqrt_(35n³+7)) -> O(sqrt_36n³) -> O(6n<sup>1.5</sup>) -> O(n<sup>1.5</sup>)    
Ω与O相反，T(n) > c.f(n)，构成下界     
Θ确界，可看作Ω与O的组合，彐 C₁ > C₂ > 0，当n>>2后,有c₁×f(n) > T(n) > C₂×f(n)   

O(1) 常数复杂度     
O(logn) 对数复杂度，通常不考虑底数，因为通过对数运算，可以给logn增加一个常系数，使底数随意变化，O(logn...)的多项式多次方同样可舍掉低次方项   
这两种比较高效   

有效解：   
多项式复杂度，一般只需要保留最高次方，例：(~~2013~~n<sup>2</sup> - ~~20n~~)/(~~1999~~n - ~~1~~) = O(n<sup>2</sup>/n) = O(n)    
其中线性复杂度：规模为n复杂度为O(n)的   
O(n<sup>c</sup>)一般都认为是有效解，且并未对c做限制   

难解(无效解法，效率不可忍受)：   
指数复杂度：O(2<sup>n</sup>)   

subset,一个集合，分为两个，两个子集合中元素的和相等（个数可能不同），幂集(对所有元素选或者不选 2<sup>n</sup>)，比如美国选举，只有O(2<sup>n</sup>)的解法，它(2-Subset问题)是典型的NPC(NP-Complete 即:就目前的计算模型而言，不存在可在多项式时间[ O(n<sup>c</sup>) ]内回答此问题的算法)问题     

指数复杂度在小尺度的时候可能比某些多项式低，但增长速度快，在足够大的之后会超过所有固定阶次的多项式   

## 绪论（下）

估算，去粗存精   
算法分析的主要任务：正确性（不变性 × 单调性）+ 复杂度   
考察复杂度，不需要将算法描述为 RAM 的基本指令，在渐进意义下，C++等高级语言的基本指令与RAM相当   

迭代：级数：算数级数：T(n) = 1 + 2 + ... + n = n(n+1)/2 = O(n²)     
平方和：1² + 2² + ... + n² = n(n+1)(2n+!)/6 = O(n³)   
立方级数求和:1³ + 2³ + …… + n³ = [n(n+1)]²/4 = O(n<sup>4</sup>)   
4次方级数求和 : [n(n+1)(2n+1)(3n²+3n−1)]/30 = O(n<sup>5</sup>)   
https://saaavsaaa.github.io/jax/escape.html   
$$
\sum_{k=0}^{n}{k^d} ≈ ∫_0^nx^ddx = \frac{1}{d+1}n^{d+1} = O(n^{d+1}) 
$$   
几何级数：末项    
a<sup>0</sup> + a<sup>1</sup> + ... + a<sup>n</sup> = (a<sup>n+1</sup> - 1)/(a - 1) = O(a<sup>n</sup>)   
1 + 2 + 4 + ... + 2<sup>n</sup> = 2<sup>n+1</sup> - 1 = O(2<sup>n+1</sup>) = O(2<sup>n</sup>)   

收敛级数：上界   
1 - 1/n = O(1)   
1 + 1/2² + ... + 1/n² = π²/6 = O(1)   
存储单元和操作不可能是分数，但可能是计算概率的、判断命中情况的几何分布：1/(1-λ) = O(1)   

未必收敛但项数有限:确界，**这两种很常用**   
1 + 1/2 + ... + 1/n = Θ(logn)   调和级数   
log1 + log2 + ... + logn = log(n!) = Θ(nlogn)   对数级数  

扩展阅读：《Concrete Mathematics》有很多相关内容，和其他复杂度情况介绍   

i=0;i<n;i++嵌套j=0;j<i;j++也是O(n²)  : 0 + 1 + ... + n-1 = n(n-1)/2，几何图形表示相当于一个三角形的面积，算数级数   
1.如果外循环的i++换成i <<= 1(代表左移一位，相当于×2)，几何级数，O(n) : 1 + 2 + 4 + ... + 2<sup>log<sub>2</sub>(n-1)</sup>   
2.如果内循环j++换成 j+j,∑<sub>0</sub><sup>i</sup>[log<sub>2</sub>i] = O(nlogn)，∑<sub>k=0...logn</sub>(k×2<sup>k-1</sup>) = O(logn × 2<sup>logn</sup>)   
数学上的级数通常是无限项, 但是在时间复杂度的计算中出现的级数, 通常是级数的有限项的和, 例如在数据规模为n的时候复杂度是级数的前n项   

找集合中的非极端元素，只需要随机选三个元素，取中间的那个，它就一定是非极端元素，无论集合多大：O(1)   Θ(1)   
气泡排序：嵌套循环   
正确性：有穷性：不变性:经k轮扫描交换后,最大的k个元素必然就位(一轮一个，一轮k次，第k大元素k次比较交换)；单调性:经k轮扫描交换后,问题规模缩减至n-k。正确性:经至多n趟扫描后，算法必然终止，且能给出正确解答。   

Back-0f-The-Envelope Calculation 封底估算   
CPU 一秒 gigahertz 10<sup>9</sup>，一天约10<sup>5</sup>(量级，估计 24×3600≈25×4000) sec，1世纪100年≈3×10<sup>9</sup>，“三生三世” ≈300 yr = 10<sup>10</sup> sec = (1 googel)<sup>1/10</sup> sec，宇宙大爆炸至今= 10<sup>21</sup> = 10×(10<sup>10</sup>)<sup>2</sup>     
全国人口普查排序估计：     
|      n = 10<sup>9</sup>     |   普通PC：1GHZ：10<sup>9</sup>次浮点运算      |     天河1A：千万亿次：1P：10<sup>15</sup>次浮点运算   |
|:--|:--|:--|
|  气泡排序 n² (10<sup>9</sup>)² |  10<sup>9</sup> sec [(10<sup>9</sup>)²÷10<sup>9</sup>] ： 30年 |     10<sup>3</sup> sec ： 20分钟    |
|  归并排序 nlogn 10<sup>9</sup>log<sub>2</sub>(10<sup>9</sup>) 30×10<sup>9</sup> |  30 sec |     0.03 毫秒   |


求n个数之和：循环O(n)，空间复杂度通常不计算输入的空间占用：O(2) O(1) 常数，循环，每次减少一个，子问题减少     
减而治之Decrease-and-conquer：为求解一个大规模的问题,可以将其划分为两个子问题:其一平凡，另一规模缩减。分别求解子问题，由子问题的解，得到原问题的解。     
递归跟踪( recursion trace) 分析检查每个递归实例，累计所需时间(调用语句本身,计入对应的子实例)，其总和即算法执行时间   
本例中，单个递归实例自身只需O(1)，时间T(n) = O(1) * (n+1) = O(n)，线性，最简单的递归形式，线性递归，可以使用递归跟踪方法分析     
递归跟踪:直观形象:仅适用于简明的递归模式   
递推方程:间接抽象.更适用于复杂的递归模式   
从递推的角度看,为求解sum(A, n) ,需递归求解规模为n-1的问题sum(A，n-1)再累加上A[n-1],递归基: sum(A，0)     
递推方程:T(n) = T(n-1) + O(1)   T(0) = O(1)
求解：T(n) - n = T(n-1) - (n-1) = T(n-2) - (n-2) = ... = T(2) - 2 = T(1) - 1 = T(0) - 0
      T(n) = O(1) + n =  O(n)   

分而治之[Divide- and-conquer]：为求解一个大规模的问题,可以将其划分为若干(通常两个)子问题,规模大体相当，分别求解子问题，由子问题的解,得到原问题的解   
例：数组求和，递归分两段分别求和，直到每小段和只剩一个元素，T(n) = 各层递归实例所需时间之和 = O(1) x(2<sup>0</sup> + 2<sup>1</sup>+2²+..+ 2<sup>logn</sup>) = O(1) x (2<sup>logn+1</sup> - 1) = O(n)。更简单的方法：画成递归跟踪图实际就是二叉树的形式，每次递归分两段，叶子节点数的阶；它就是个公比为2的几何级数，几何级数与末项同阶(2<sup>logn</sup>)。递推方法：每个分两个+ 递归基的常数c [O(1)] 时间:T(n) = 2 * T(n/2) + c = 2²[T(n/4) + c]... = 2<sup>logn</sup>[T(1) + c] = n(c<sub>t</sub> + c)，(2<sup>log₂n</sup>=n)     
数组求其中最大的两个值，由最好n-1、最坏2n-3优化，二分递归最差T(n) = 2 * T(n/2) + 2, 左右加2(二分以后各自比较2 * 1)，T(n) + 2 = 2*[T(n/2)+2] = 2²*[T(n/4)+2] = ... = 2<sup>k</sup> * [T(n/k)+2],k=logn。当数组只有两个元素T(2) = 1，只有三个元素T(3) <= 3。递归基最差情况T(3) = 3，规模为n的二分递归第一次分n/2个、第二次分n/2²个、第n次分/n2<sup>logn</sup>个，每个最差3次，也就是说n/2<sup>k</sup> = 3，2<sup>k</sup> = n/3，T(n) + 2 = 2<sup>k</sup> * [T(n/k)+2] = n/3 * (T(3)+2)，T(n)=5n/3-2。实际上任何形式上满足 T(n) = k * n - 2 的通项公式都可以满足递归式T(n) = 2 * T(n/2) + 2。但是这里要带入初始条件即 T(3) <= 3, 由此可推出 T(n) <= (5/3)n - 2。   

http://dsa.cs.tsinghua.edu.cn/~deng/ds/dsacpp/?from=singlemessage
DSA 设计与优化的一种重要手段：动态规划   
递归可以满足work和right，但有时候不够快，从某种角度来说，动态规划从某种意义上将，也可以理解为先用递归找出算法的本质并给出一个初步的解，再等效的转化为迭代提高效率   
https://github.com/saaavsaaa/warn-report/blob/master/src/test/java/cn/tellwhy/structure/FibonacciTest.java   
递推关系：T(n) = T(n-1) + T(n-2) +　1, n > 1 , T(0) = T(1) = 1　　
设 S(n) = [T(n) + 1] /2   
则 S(0) = 1 = fib(1)，S(1) = 1 = fib(2)   
故 S(n) = S(n-1) + S(n-2) = fib(n+1) 复杂度O(Φ<sup>n</sup>)  Φ:斐波那契数列通项黄金分割，空间复杂度O(n)      
S(n)相当于fib(n+1)向后推了一项   
T(n) = 2 * S(n) - 1 = 2 * fib(n+1) - 1 = O(fib(n+1)) = O(Φ<sup>n</sup>) = O(2<sup>n</sup>)   Φ严格比1大,它的递归算法复杂度也呈现出斐波那契数列形式      
封底估算：     
Φ<sup>36</sup> = 2<sup>25</sup>   *=>*  算出第43项 ：Φ<sup>43</sup> = 2<sup>30</sup>  ≈  10<sup>9</sup> flo（条基本指令） = 主流PC 1 sec      
Φ<sup>5</sup> = 10   *=>*  Φ<sup>67</sup>  ≈  10<sup>14</sup> flo  =  10<sup>5</sup> sec = 1 day     
Φ<sup>92</sup> ≈ 10<sup>19</sup> flo = 10<sup>10</sup> sec = 10<sup>5</sup> day = 3 century 相当于在有穷时间内得不到结果，严格来说都不能算是算法     
递归版fib()低效的根源在于，各递归实例均被大量重复地调用。每算一项，都要分别递归计算出其前两项，而实际上没必要分别算，因为可以用n-1项算出第n项   

解决方法A (记忆: memoization)将已计算过实例的结果制表备查     
解决方法B (动态规划: dynamic programming)颠倒计算方向:由自顶而下递归，为自底而上迭代。T(n) = O(n) ,而且仅需O(1)空间（保存当前的两个值）     
最长公共子序列：两个序列中同时存在的序列中最长的(可能不唯一)，序列中的字符可以不相邻，但是顺序必须一致     
递归：必对于序列A[0, n]和B[0, m], LCS(A, B)无非3种情况：     
0)若n=-1或m=-1,则取作空序列(”“)  ： 递归基     
1)若A[n] = 'X'= B[m]，则取作LCS(A\[0, n), B\[0, m)) + 'X' ：  减而治之   
2) A[n] ≠B[m]，则在LCS(A[0, n], B[0, m))与LCS(A[0， n), B[0，m])中取更长者。A或B的尾字符无用两种情况，用A和B分别递归这两种情况。     
正确性可以保证，因为单调性:无论如何,每经过一次比对,原问题的规模必可减小，具体地，作为输入的两个序列，至少其一的长度缩短一个单位
最好情况(不出现第2种情况)下，只需O(n+m)时间   
但问题在于，(在第2种情况)原问题将分解为两个子问题，更糟糕的是,它们在随后进一步导出的子问题,可能雷同(abc、abd可能不同，但是递归子问题后，子问题的子问题都是ab)   


-----

[edit](https://github.com/saaavsaaa/saaavsaaa.github.io/edit/master/aaa/Structure_Abstract.md)

## 绪论（上）

计算模型=计算机=信息处理工具    
所谓算法,即特定计算模型下,旨在解决特定问题的指令序列:   
输入 待处理的信息(问题)   
输出 经处理的信息(答案)   
正确性 的确可以解决指定的问题   
确定性 任一算法都可以描述为一个由基本操作组成的序列   
可行性 每一基本操作都可实现,且在常数时间内完成   
有穷性 对于任何输入，经有穷次基本操作,都可以得到输出   

有穷性的反例算法:Hailstore,≤ 1结束，> 1 偶数时 ÷ 奇数时 ×3+1。这个逻辑的程序暂时还没有办法证明是否所有输入都有穷，虽然还没有反例 42、7、27。     

好算法：正确、效率、健壮、可读   

数据结构和算法(DSA)想要优化，首先需要测量     
算法分析两个方面：     
正确性：算法功能与需求是否一致，可能需要借助数学工具进行证明     
成本：运行时间和所需的存储空间     
这里更多关注时间成本     
如何度量？如何比较？
求解问题实例意义不大，因为可能的实例太多，如何归纳？
计算成本 **一般情况下** 和问题规模相关，一般是正相关

必实验统计是最直接的方法,但不足以准确反映算法的真正效率。
不同的算法,可能更适应于不同规模的输入。
不同的算法，可能更适应于不同类型的输入。
同一算法，可能由不同程序员、用不同程序语言、经不同编译器实现。
同一算法,可能实现并运行于不同的体系结构、操作系统...

需要抽象出一种理想的平台或模型:例如图灵机模型
Tape 依次均匀地划分为单元格各注有某一字符，默认可以为'#'   
Alphabet字符的种类有限   
Head 总是对准某一单元格，并可读取和改写其中的字符，每经过一个节拍，可转向左侧或右侧的邻格   
Transition Function: (q, C; d, L/R, p)若当前状态为q且当前字符为c，则将当前字符改写为d ;转向左侧/右侧的邻格;转入p状态；一旦转入特定的状态'h'则停机   
图灵机实例：将二进制非负整数加一：全'1'的后缀翻转为全'0'，原最低位的'0'或'#'翻转为'1'：     
(<，1, 0, L, <) //左行，1->0，可能多次使用    
(<, 0, 1, R, >) //掉头，0->1     
(<，#，1,R,>)  // 或者遇到# 翻转为1 
(>, 0, 0, R, >) //右行   
(>, #，#，L, h) //复位   
复位是因为这一段有可能是一个算法的一部分，需要反复使用，这是一种规范，多通过接口形式规定     

RAM(Random Access Machine)模型：做加法时，需要先将常数放进寄存器，再对寄存器进行相加     
与图灵机相同：寄存器顺序编号，总数没有限制；基本操作仅需常数时间；     
与TM模型一样，RAM模型也是一般计算工具的简化与抽象，使我们可以独立于具体的平台,对算法的效率做出可信的比较与评判，算法效率不取决于CPU的主频，而取决与CPU的计算次数     
在这些模型中，算法的运行时间可转化为算法需要执行的基本操作次数，衡量算法效率的函数T(n) = 算法为求解规模为n的问题,所需执行的基本操作次数。   

大 O 记号(big-o notation)，更关心足够大的问题，注重考察成本的增长趋势而不是某个运算过程的局部细节   
渐进分析：当问题规模足够大后，计算成本如何增长   
当 n 足够大，对与输入规模为n的算法：   
需执行的基本操作次数   
需占用的存储单元数（通常可不考虑）   
多项式复杂度，舍掉低阶项

T(n)=0(f(n)) iff 彐 c > 0，当n>>2后,有T(n) < c.f(n)      
反映T(n)的增长趋势，T(n)时间复杂度常系数意义上的的上界(经过常系数放大能构成上界)，局部值不一定小于T(n)     
常数项可以忽略，低次项可以忽略 O(sqrt_(35n³+7)) -> O(sqrt_36n³) -> O(6n<sup>1.5</sup>) -> O(n<sup>1.5</sup>)    
Ω与O相反，T(n) > c.f(n)，构成下界     
Θ确界，可看作Ω与O的组合，彐 C₁ > C₂ > 0，当n>>2后,有c₁×f(n) > T(n) > C₂×f(n)   

O(1) 常数复杂度     
O(logn) 对数复杂度，通常不考虑底数，因为通过对数运算，可以给logn增加一个常系数，使底数随意变化，O(logn...)的多项式多次方同样可舍掉低次方项   
这两种比较高效   

有效解：   
多项式复杂度，一般只需要保留最高次方，例：(~~2013~~n<sup>2</sup> - ~~20n~~)/(~~1999~~n - ~~1~~) = O(n<sup>2</sup>/n) = O(n)    
其中线性复杂度：规模为n复杂度为O(n)的   
O(n<sup>c</sup>)一般都认为是有效解，且并未对c做限制   

难解(无效解法，效率不可忍受)：   
指数复杂度：O(2<sup>n</sup>)   

subset,一个集合，分为两个，两个子集合中元素的和相等（个数可能不同），幂集(对所有元素选或者不选 2<sup>n</sup>)，比如美国选举，只有O(2<sup>n</sup>)的解法，它(2-Subset问题)是典型的NPC(NP-Complete 即:就目前的计算模型而言，不存在可在多项式时间[ O(n<sup>c</sup>) ]内回答此问题的算法)问题     

指数复杂度在小尺度的时候可能比某些多项式低，但增长速度快，在足够大的之后会超过所有固定阶次的多项式   

## 绪论（下）

估算，去粗存精   
算法分析的主要任务：正确性（不变性 × 单调性）+ 复杂度   
考察复杂度，不需要将算法描述为 RAM 的基本指令，在渐进意义下，C++等高级语言的基本指令与RAM相当   

迭代：级数：算数级数：T(n) = 1 + 2 + ... + n = n(n+1)/2 = O(n²)     
平方和：1² + 2² + ... + n² = n(n+1)(2n+!)/6 = O(n³)   
立方级数求和:1³ + 2³ + …… + n³ = [n(n+1)]²/4 = O(n<sup>4</sup>)   
4次方级数求和 : [n(n+1)(2n+1)(3n²+3n−1)]/30 = O(n<sup>5</sup>)   
https://saaavsaaa.github.io/jax/escape.html   
$$
\sum_{k=0}^{n}{k^d} ≈ ∫_0^nx^ddx = \frac{1}{d+1}n^{d+1} = O(n^{d+1}) 
$$   
几何级数：末项    
a<sup>0</sup> + a<sup>1</sup> + ... + a<sup>n</sup> = (a<sup>n+1</sup> - 1)/(a - 1) = O(a<sup>n</sup>)   
1 + 2 + 4 + ... + 2<sup>n</sup> = 2<sup>n+1</sup> - 1 = O(2<sup>n+1</sup>) = O(2<sup>n</sup>)   

收敛级数：上界   
1 - 1/n = O(1)   
1 + 1/2² + ... + 1/n² = π²/6 = O(1)   
存储单元和操作不可能是分数，但可能是计算概率的、判断命中情况的几何分布：1/(1-λ) = O(1)   

未必收敛但项数有限:确界，**这两种很常用**   
1 + 1/2 + ... + 1/n = Θ(logn)   调和级数   
log1 + log2 + ... + logn = log(n!) = Θ(nlogn)   对数级数  

扩展阅读：《Concrete Mathematics》有很多相关内容，和其他复杂度情况介绍   

i=0;i<n;i++嵌套j=0;j<i;j++也是O(n²)  : 0 + 1 + ... + n-1 = n(n-1)/2，几何图形表示相当于一个三角形的面积，算数级数   
1.如果外循环的i++换成i <<= 1(代表左移一位，相当于×2)，几何级数，O(n) : 1 + 2 + 4 + ... + 2<sup>log<sub>2</sub>(n-1)</sup>   
2.如果内循环j++换成 j+j,∑<sub>0</sub><sup>i</sup>[log<sub>2</sub>i] = O(nlogn)，∑<sub>k=0...logn</sub>(k×2<sup>k-1</sup>) = O(logn × 2<sup>logn</sup>)   
数学上的级数通常是无限项, 但是在时间复杂度的计算中出现的级数, 通常是级数的有限项的和, 例如在数据规模为n的时候复杂度是级数的前n项   

找集合中的非极端元素，只需要随机选三个元素，取中间的那个，它就一定是非极端元素，无论集合多大：O(1)   Θ(1)   
气泡排序：嵌套循环   
正确性：有穷性：不变性:经k轮扫描交换后,最大的k个元素（第看大的元素）必然就位；单调性:经k轮扫描交换后,问题规模缩减至n-k。   


-----

[edit](https://github.com/saaavsaaa/saaavsaaa.github.io/edit/master/aaa/Structure_Abstract.md)

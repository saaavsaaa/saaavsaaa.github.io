计算模型=计算机=信息处理工具    
所谓算法,即特定计算模型下,旨在解决特定问题的指令序列:   
输入 待处理的信息(问题)   
输出 经处理的信息(答案)   
正确性 的确可以解决指定的问题   
确定性 任一算法都可以描述为一个由基本操作组成的序列   
可行性 每一基本操作都可实现,且在常数时间内完成   
有穷性 对于任何输入，经有穷次基本操作,都可以得到输出   

有穷性的反例算法:Hailstore,≤ 1结束，> 1 偶数时 ÷ 奇数时 ×3+1。这个逻辑的程序暂时还没有办法证明是否所有输入都有穷，虽然还没有反例 42、7、27。     

好算法：正确、效率、健壮、可读   

数据结构和算法(DSA)想要优化，首先需要测量     
算法分析两个方面：     
正确性：算法功能与需求是否一致，可能需要借助数学工具进行证明     
成本：运行时间和所需的存储空间     
这里更多关注时间成本     
如何度量？如何比较？
求解问题实例意义不大，因为可能的实例太多，如何归纳？
计算成本 **一般情况下** 和问题规模相关，一般是正相关

必实验统计是最直接的方法,但不足以准确反映算法的真正效率。
不同的算法,可能更适应于不同规模的输入。
不同的算法，可能更适应于不同类型的输入。
同一算法，可能由不同程序员、用不同程序语言、经不同编译器实现。
同一算法,可能实现并运行于不同的体系结构、操作系统...

需要抽象出一种理想的平台或模型:例如图灵机模型
Tape 依次均匀地划分为单元格各注有某一字符，默认可以为'#'   
Alphabet字符的种类有限   
Head 总是对准某一单元格，并可读取和改写其中的字符，每经过一个节拍，可转向左侧或右侧的邻格   
Transition Function: (q, C; d, L/R, p)若当前状态为q且当前字符为c，则将当前字符改写为d ;转向左侧/右侧的邻格;转入p状态；一旦转入特定的状态'h'则停机   
图灵机实例：将二进制非负整数加一：全'1'的后缀翻转为全'0'，原最低位的'0'或'#'翻转为'1'：     
(<，1, 0, L, <) //左行，1->0，可能多次使用    
(<, 0, 1, R, >) //掉头，0->1     
(<，#，1,R,>)  // 或者遇到# 翻转为1 
(>, 0, 0, R, >) //右行   
(>, #，#，L, h) //复位   
复位是因为这一段有可能是一个算法的一部分，需要反复使用，这是一种规范，多通过接口形式规定     

RAM(Random Access Machine)模型：     
与图灵机相同：寄存器顺序编号，总数没有限制；基本操作仅需常数时间；与TM模型- -样，RAM模型也是一般计算工具的简化与抽象，使我们可以独立于具体的平台,对算法的效率做出可信的比较与评判     
